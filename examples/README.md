

## Testbench examples

Note: These examples will be completed with monitors and will be updated along with the framework.

### Structure
All testbench examples follow the same structure:
- block\_design.png: screenshot of the Vivado block design that represents the DUT
- address\_map.png: map of AXI addresses (not for interconnect\_stream since there is only AXI-Stream interfaces)
- src/ contains vhdl sources
- tests/ contains different tests (one or multiple per file)
- tb.py is the testbench. Its purpose it to avoid code duplication.
Its constructor builds the testbench by connecting the framework's (or cocotbext-axi's) components to axi buses.
Each test should build a testbench object to have a direct access to each attributes and methods directly in one line:
`tb = TB(dut)`.
We can also put a reset method in the TB class to be able to call `tb.reset()` at any time during the test.
- inputs/ contains the input files for the tests.file\_inputs test
- Makefile: allows to
    - compile the design with GHDL using `make analysis`
    - run the tests listed in the Makefile's MODULE variable using `make`
    - run all tests in a file using `make MODULE=tests.testname`
- wave.ghw and wave.vcd: signal dump that can be opened with gtkwave
- results.xml: generated by cocotb, gives information on the last test run with:
    - the random seed used
    - which test passed and which failed

